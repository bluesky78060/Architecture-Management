{"version":3,"file":"static/js/288.62c9b4b6.chunk.js","mappings":"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","sources":["services/browserFs.ts","utils/imageStorage.ts"],"sourcesContent":["// Experimental browser folder storage using File System Access API (Edge/Chrome)\n\nimport '../types/global';\n\nconst DB_NAME = 'cms-fs';\nconst STORE = 'handles';\nconst DIR_KEY = 'dirHandle';\n\nfunction isSupported(): boolean {\n  return typeof window !== 'undefined' && 'showDirectoryPicker' in window;\n}\n\nfunction openDb(): Promise<IDBDatabase> {\n  return new Promise((resolve, reject) => {\n    const req = indexedDB.open(DB_NAME, 1);\n    req.onupgradeneeded = () => {\n      const db = req.result;\n      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);\n    };\n    req.onsuccess = () => resolve(req.result);\n    req.onerror = () => reject(req.error);\n  });\n}\n\nasync function idbGet(key: string): Promise<unknown> {\n  const db = await openDb();\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORE, 'readonly');\n    const st = tx.objectStore(STORE);\n    const req = st.get(key);\n    req.onsuccess = () => resolve(req.result ?? null);\n    req.onerror = () => reject(req.error);\n  });\n}\n\nasync function idbSet(key: string, value: unknown): Promise<void> {\n  const db = await openDb();\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORE, 'readwrite');\n    const st = tx.objectStore(STORE);\n    const req = st.put(value, key);\n    req.onsuccess = () => resolve();\n    req.onerror = () => reject(req.error);\n  });\n}\n\nasync function getSavedDirectoryHandle(): Promise<FileSystemDirectoryHandle | null> {\n  if (!isSupported()) return null;\n  try {\n    const handle = (await idbGet(DIR_KEY)) as FileSystemDirectoryHandle | null;\n    return handle ?? null;\n  } catch (e) {\n    return null;\n  }\n}\n\nasync function saveDirectoryHandle(handle: FileSystemDirectoryHandle): Promise<boolean> {\n  if (!isSupported()) return false;\n  try {\n    await idbSet(DIR_KEY, handle);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nasync function verifyPermission(\n  handle: FileSystemDirectoryHandle, \n  mode: 'read' | 'readwrite' = 'readwrite'\n): Promise<boolean> {\n  if (handle == null) return false;\n  if (await handle.queryPermission({ mode }) === 'granted') return true;\n  if (await handle.requestPermission({ mode }) === 'granted') return true;\n  return false;\n}\n\nasync function chooseDirectory(): Promise<FileSystemDirectoryHandle | null> {\n  if (!isSupported()) return null;\n  try {\n    if (typeof window.showDirectoryPicker !== 'function') return null;\n    const handle = await window.showDirectoryPicker({ id: 'cms-data' });\n    if (!(await verifyPermission(handle, 'readwrite'))) return null;\n    await saveDirectoryHandle(handle);\n    return handle;\n  } catch (e) {\n    return null;\n  }\n}\n\nasync function getFileHandle(\n  dirHandle: FileSystemDirectoryHandle, \n  name: string\n): Promise<FileSystemFileHandle> {\n  return await dirHandle.getFileHandle(name, { create: true });\n}\n\nasync function readKey(\n  dirHandle?: FileSystemDirectoryHandle | null, \n  key?: string\n): Promise<unknown> {\n  try {\n    if (dirHandle == null) dirHandle = await getSavedDirectoryHandle();\n    if (dirHandle == null || key == null || key === '') return null;\n    if (!(await verifyPermission(dirHandle, 'read'))) return null;\n    const fileHandle = await getFileHandle(dirHandle, `${key}.json`);\n    const file = await fileHandle.getFile();\n    const text = await file.text();\n    if (text.length === 0) return null;\n    return JSON.parse(text);\n  } catch (e) {\n    return null;\n  }\n}\n\nasync function writeKey(\n  dirHandle: FileSystemDirectoryHandle | null, \n  key: string, \n  obj: unknown\n): Promise<boolean> {\n  try {\n    if (dirHandle == null) dirHandle = await getSavedDirectoryHandle();\n    if (dirHandle == null) return false;\n    if (!(await verifyPermission(dirHandle, 'readwrite'))) return false;\n    const fileHandle = await getFileHandle(dirHandle, `${key}.json`);\n    const writable = await fileHandle.createWritable();\n    const INDENT = 2; // eslint-disable-line no-magic-numbers\n    await writable.write(new Blob([JSON.stringify(obj, null, INDENT)], { type: 'application/json' }));\n    await writable.close();\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nasync function writeKeyDirect(key: string, value: unknown): Promise<boolean> {\n  const dir = await getSavedDirectoryHandle();\n  if (dir == null) return false;\n  return await writeKey(dir, key, value);\n}\n\nasync function writeImageFile(filename: string, blob: Blob): Promise<boolean> {\n  try {\n    const dirHandle = await getSavedDirectoryHandle();\n    if (dirHandle == null) return false;\n    if (!(await verifyPermission(dirHandle, 'readwrite'))) return false;\n\n    const fileHandle = await dirHandle.getFileHandle(filename, { create: true });\n    const writable = await fileHandle.createWritable();\n    await writable.write(blob);\n    await writable.close();\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nexport const browserFs = {\n  isSupported,\n  getSavedDirectoryHandle,\n  saveDirectoryHandle,\n  chooseDirectory,\n  readKey,\n  writeKey,\n  writeKeyDirect,\n  writeImageFile,\n};\n","// 도장 이미지 저장을 위한 유틸리티\nimport { KIB } from '../constants/units';\nimport { browserFs } from '../services/browserFs';\n\nconst DB_NAME = 'ConstructionAppDB';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'stampImages';\nconst STAMP_KEY = 'companyStamp';\nconst STAMP_FILENAME = 'company-stamp.png';\n\n// Storage info interface\ninterface StorageInfo {\n  used: string;\n  stampImageSize: string;\n  folderPath?: string;\n}\n\n// IndexedDB 초기화\nconst openDB = (): Promise<IDBDatabase> => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n    request.onerror = () => reject(request.error);\n    request.onsuccess = () => resolve(request.result);\n\n    request.onupgradeneeded = (event) => {\n      const db = (event.target as IDBOpenDBRequest).result;\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\n        db.createObjectStore(STORE_NAME);\n      }\n    };\n  });\n};\n\n// IndexedDB와 브라우저 저장소 폴더에 이미지 저장\nexport const saveStampImage = async (imageDataUrl: string): Promise<boolean> => {\n  try {\n    // Base64를 Blob으로 변환\n    const response = await fetch(imageDataUrl);\n    const blob = await response.blob();\n\n    // 용량 확인 (5MB 제한)\n    const MAX_STAMP_IMAGE_MIB = 5;\n    const maxSize = MAX_STAMP_IMAGE_MIB * KIB * KIB;\n    if (blob.size > maxSize) {\n      return false;\n    }\n\n    // 1. IndexedDB에 저장 (백업용)\n    const db = await openDB();\n    const transaction = db.transaction([STORE_NAME], 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n\n    await new Promise<void>((resolve, reject) => {\n      const request = store.put(blob, STAMP_KEY);\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(request.error);\n    });\n\n    db.close();\n\n    // 2. 브라우저 저장소 폴더에 파일로 저장 (선택된 폴더가 있는 경우)\n    if (browserFs.isSupported()) {\n      try {\n        await browserFs.writeImageFile(STAMP_FILENAME, blob);\n      } catch (fileError) {\n        // 파일 저장 실패해도 IndexedDB에는 저장되었으므로 계속 진행\n      }\n    }\n\n    return true;\n  } catch (error) {\n    // Failed to save stamp image\n    return false;\n  }\n};\n\n// IndexedDB에서 이미지 불러오기 (Blob을 Data URL로 변환)\nexport const loadStampImage = async (): Promise<string | null> => {\n  try {\n    const db = await openDB();\n    const transaction = db.transaction([STORE_NAME], 'readonly');\n    const store = transaction.objectStore(STORE_NAME);\n\n    const blob = await new Promise<Blob | null>((resolve, reject) => {\n      const request = store.get(STAMP_KEY);\n      request.onsuccess = () => {\n        const result = request.result;\n        resolve((result !== undefined && result !== null) ? result : null);\n      };\n      request.onerror = () => reject(request.error);\n    });\n\n    db.close();\n\n    if (blob === null) return null;\n\n    // Blob을 Data URL로 변환\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = () => resolve(reader.result as string);\n      reader.onerror = () => reject(reader.error);\n      reader.readAsDataURL(blob);\n    });\n  } catch (error) {\n    // Failed to load stamp image\n    return null;\n  }\n};\n\n// IndexedDB에서 이미지 삭제\nexport const removeStampImage = async (): Promise<boolean> => {\n  try {\n    const db = await openDB();\n    const transaction = db.transaction([STORE_NAME], 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n\n    await new Promise<void>((resolve, reject) => {\n      const request = store.delete(STAMP_KEY);\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(request.error);\n    });\n\n    db.close();\n    return true;\n  } catch (error) {\n    // Failed to remove stamp image\n    return false;\n  }\n};\n\n// localStorage 저장 공간 확인\nexport const checkStorageAvailable = (): boolean => {\n  try {\n    const test = 'test';\n    localStorage.setItem(test, test);\n    localStorage.removeItem(test);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\n// 이미지 파일을 Base64로 변환\nexport const imageToBase64 = (file: File): Promise<string> => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = (e) => {\n      const result = e.target?.result;\n      if (typeof result === 'string') {\n        resolve(result);\n      } else {\n        reject(new Error('Failed to convert file to base64'));\n      }\n    };\n    reader.onerror = (error) => reject(error);\n    reader.readAsDataURL(file);\n  });\n};\n\n// 저장 폴더 경로 가져오기\nexport const getStampFolderPath = async (): Promise<string | null> => {\n  try {\n    const folderHandle = await browserFs.getSavedDirectoryHandle();\n    if (folderHandle !== null) {\n      return folderHandle.name;\n    }\n    return null;\n  } catch (error) {\n    return null;\n  }\n};\n\n// IndexedDB 사용량 확인 (개발용)\nexport const getStorageInfo = async (): Promise<StorageInfo> => {\n  let total = 0;\n\n  // localStorage 사용량\n  for (const key in localStorage) {\n    if (localStorage.hasOwnProperty(key)) {\n      total += localStorage[key].length + key.length;\n    }\n  }\n\n  // IndexedDB에서 도장 이미지 크기 확인\n  let stampImageSize = '0 KB';\n  let folderPath: string | undefined = undefined;\n\n  try {\n    const db = await openDB();\n    const transaction = db.transaction([STORE_NAME], 'readonly');\n    const store = transaction.objectStore(STORE_NAME);\n\n    const blob = await new Promise<Blob | null>((resolve, reject) => {\n      const request = store.get(STAMP_KEY);\n      request.onsuccess = () => {\n        const result = request.result;\n        resolve((result !== undefined && result !== null) ? result : null);\n      };\n      request.onerror = () => reject(request.error);\n    });\n\n    db.close();\n\n    if (blob !== null) {\n      stampImageSize = Math.round(blob.size / KIB) + ' KB';\n    }\n\n    // 폴더 경로 가져오기\n    const path = await getStampFolderPath();\n    if (path !== null) {\n      folderPath = path;\n    }\n  } catch (error) {\n    // Failed to get storage info\n  }\n\n  return {\n    used: Math.round(total / KIB) + ' KB',\n    stampImageSize: stampImageSize,\n    folderPath: folderPath\n  };\n};\n"],"names":["STORE","DIR_KEY","isSupported","window","openDb","Promise","resolve","reject","req","indexedDB","open","onupgradeneeded","db","result","objectStoreNames","contains","createObjectStore","onsuccess","onerror","error","async","getSavedDirectoryHandle","handle","key","transaction","objectStore","get","_req$result","idbGet","e","saveDirectoryHandle","value","put","idbSet","verifyPermission","mode","arguments","length","undefined","queryPermission","requestPermission","getFileHandle","dirHandle","name","create","writeKey","obj","fileHandle","concat","writable","createWritable","INDENT","write","Blob","JSON","stringify","type","close","browserFs","chooseDirectory","showDirectoryPicker","id","readKey","file","getFile","text","parse","writeKeyDirect","dir","writeImageFile","filename","blob","STORE_NAME","STAMP_KEY","openDB","request","event","target","saveStampImage","response","fetch","imageDataUrl","maxSize","KIB","size","store","fileError","loadStampImage","reader","FileReader","onload","readAsDataURL","removeStampImage","delete","imageToBase64","_e$target","Error"],"sourceRoot":""}